<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Pythagorean theorem</title>

    <link href="https://fonts.googleapis.com/css?family=Open+Sans" rel="stylesheet">
    <style>

        circle {
            fill: #000;
            fill-opacity: 1;
        }

        line {
            stroke: #000;
            stroke-width: 2px;
        }

        text {
            font-family: 'Open Sans', sans-serif;
            font-size: 18px;
            font-weight: bold;
            fill: #000;
        }

        .split {
            stroke: #808080;
        }

        .splitLine {
            stroke-dasharray: 5, 5;
        }

        .active {
            stroke: #000;
            stroke-width: 2px;
        }

    </style>
</head>
<body>

<script src="https://d3js.org/d3.v4.min.js"></script>
<script>
    'use strict';

    const height = 350;
    const width = 700;

    const formula = ['a²', '+', 'b²', '=', 'c²'];
    const scalingFactor = 20;
    let vectorCoords = {'x': 100, 'y': 100};

    let svg = d3.select('body').append('svg')
        .attr('width', width)
        .attr('height', height);

    radioInit();
    formulaInit();
    triangleInit();

    // Initialise everything

    function radioInit() {

        const radioOffset = {'x': 30, 'y': 60, 'button': 50, 'textX': 20, 'textY': 4};
        const radioRadius = 15;
        const radioText = ['formula', 'numbers'];

        svg.append('g')
            .attr('transform', `translate(${radioOffset.x},${radioOffset.y})`)
            .attr('id', 'radio');
        for (let m = 0; m < radioText.length; m++) {
            d3.select('#radio').append('circle')
                .attr('cy', radioOffset.button * m)
                .attr('r', radioRadius)
                .attr('id', radioText[m] + 'Radio')
                .style('fill', '#8db6be')
                .classed('active', !m);
            d3.select('#radio').append('text')
                .attr('x', radioOffset.textX)
                .attr('y', radioOffset.button * m + radioOffset.textY)
                .text(radioText[m]);

        }

        d3.select('#formulaRadio').on('click', clickFormula);
        d3.select('#numbersRadio').on('click', clickNumbers);

    }

    function formulaInit() {

        const formulaOffset = {'x': 1/3*(width), 'y': 70};
        const fontSize = {'letter': 50, 'symbol': 35};

        svg.append('g')
            .attr('transform', `translate(${formulaOffset.x},${formulaOffset.y})`)
            .attr('id', 'formulaContainer');
        d3.select('#formulaContainer').selectAll('text')
            .data(d3.range(formula.length))
            .enter().append('text')
            .attr('id', function(d) {return `formula${d}`; })
            .style('font-size', function(d) {return d % 2 ? `${fontSize.symbol}px` : `${fontSize.letter}px`; });

        if (d3.select('#formulaRadio').classed('active')) {
            updateFormula();
        } else {
            updateNumbers();
        }
    }

    function triangleInit() {

        triangleContainersInit();
        arrowHeadInit();
        lineBodyInit();
        textInit();
        ballInit();

        updateTriangle();

        function triangleContainersInit() {
            svg.append('g')
                .attr('transform', `translate(${(1/3)*width},${height-20})`)
                .attr('id', 'triangle');
            d3.select('#triangle').append('g')
                .attr('id', 'triangleRight');
            d3.select('#triangleRight').append('g')
                .attr('id', 'triangleTop');
            d3.select('#triangle').append('g')
                .attr('id', 'velocity');
            d3.select('#velocity').append('g')
                .attr('id', 'velocityArrowHead');
        }

        function arrowHeadInit() {
            const arrowOffset = 10;

            // horizontal line arrowHead
            d3.select('#triangleRight').selectAll('line')
                .data(d3.range(2))
                .enter().append('line')
                .attr('x2', -arrowOffset)
                .attr('y2', function(d) {return (d ? -1 : 1)*arrowOffset; })
                .classed('split', true);

            // vertical line arrowhead
            d3.select('#triangleTop').selectAll('line')
                .data(d3.range(2))
                .enter().append('line')
                .attr('x2', function(d) {return (d ? -1 : 1)*arrowOffset; })
                .attr('y2', arrowOffset)
                .classed('split', true);

            // vector arrowHead
            d3.select('#velocityArrowHead').selectAll('line')
                .data(d3.range(2))
                .enter().append('line')
                .attr('x2', -arrowOffset)
                .attr('y2', function(d) {return (d ? -1 : 1)*arrowOffset; });
        }

        function lineBodyInit() {
            // horizontal line
            d3.select('#triangle').append('line')
                .attr('id', 'horizontalVel')
                .classed('split', true)
                .classed('splitLine', true);
            // vertical line
            d3.select('#triangleRight').append('line')
                .attr('id', 'verticalVel')
                .classed('split', true)
                .classed('splitLine', true);
            // vector line
            d3.select('#velocity').append('line')
                .attr('id', 'vectorLineBody');
        }

        function textInit() {

            const textOffset = {'horizontal': 18, 'vertical': -5, 'velocity': -5};

            d3.select('#triangle').append('text')
                .attr('y', textOffset.horizontal)
                .attr('id', 'textX');
            d3.select('#triangleRight').append('text')
                .attr('transform', 'rotate(90)')
                .attr('y', textOffset.vertical)
                .attr('id', 'textY');
            d3.select('#velocity').append('text')
                .attr('y', textOffset.velocity)
                .attr('id', 'textVel');

        }

        function ballInit() {

            const ball = {'fixedR': 7, 'dragR': 15};

            // fixed ball
            d3.select('#triangle').append('circle')
                .attr('r', ball.fixedR);
            // draggable ball
            d3.select('#triangle').append('circle')
                .attr('r', ball.dragR)
                .attr('id', 'dragBall')
                .style('fill-opacity', 0.3)
                .style('fill', '#2c8f9c')
                .call(d3.drag()
                    .on("start", dragStart)
                    .on("drag", dragging)
                    .on("end", dragEnd));
        }
    }


    //On click

    function clickFormula() {
        d3.select(this).classed('active',true);
        d3.select('#numbersRadio').classed('active', false);

        updateFormula();
    }

    function clickNumbers() {
        d3.select(this).classed('active',true);
        d3.select('#formulaRadio').classed('active', false);

        updateNumbers();
    }


    // Drags

    function dragStart() {
        d3.select(this).classed("active", true);
    }

    function dragging() {
        const lim = {'minX': 40, 'minY': 40, 'maxX': 200, 'maxY': 200};

        vectorCoords.x = Math.max(Math.min(d3.event.x, lim.maxX), lim.minX);
        vectorCoords.y = Math.max(Math.min(-d3.event.y, lim.maxY), lim.minY);

        updateTriangle();

        if (d3.select('#numbersRadio').classed('active')) {
            updateNumbers();
        }

    }

    function dragEnd() {
        d3.select(this).classed("active", false);
    }


    // Dynamic updates

    function updateTriangle() {

        const dragOffset = 4;
        const rad2deg = 180/Math.PI;
        const deg2rad = 1/rad2deg;

        let vel = Math.sqrt(Math.pow(vectorCoords.x,2) + Math.pow(vectorCoords.y,2));
        let angle = Math.atan(vectorCoords.y/vectorCoords.x)*rad2deg;

        updateContainers();
        updateLineBodies();

        d3.select('#dragBall')
            .attr('cx', vectorCoords.x - dragOffset*Math.cos(angle*deg2rad))
            .attr('cy', -vectorCoords.y + dragOffset*Math.sin(angle*deg2rad));

        updateText();

        function updateContainers() {

            d3.select('#triangleRight').attr('transform', `translate(${vectorCoords.x},0)`);
            d3.select('#triangleTop').attr('transform', `translate(0,${-vectorCoords.y})`);
            d3.select('#velocity').attr('transform', `rotate(${-angle})`);
            d3.select('#velocityArrowHead').attr('transform', `translate(${vel},0)`);

        }

        function updateLineBodies() {

            d3.select('#vectorLineBody').attr('x2', vel);
            d3.select('#horizontalVel').attr('x2', vectorCoords.x);
            d3.select('#verticalVel').attr('y2', -vectorCoords.y);

        }

        function updateText() {

            const textOffset = 5;

            let scaledX = Math.round(vectorCoords.x/scalingFactor);
            let scaledY = Math.round(vectorCoords.y/scalingFactor);
            let scaledVel = Math.round(Math.pow(Math.pow(scaledX, 2)+Math.pow(scaledY, 2), (1/2))*10)/10;

            d3.select('#textX')
                .attr('x', vectorCoords.x/2 - textOffset)
                .text(scaledX);
            d3.select('#textY')
                .attr('x', -vectorCoords.y/2)
                .text(scaledY);
            d3.select('#textVel')
                .attr('x', vel/2 - 3*textOffset)
                .text(scaledVel);

        }

    }

    function updateFormula() {

        const textGap = {'char': 36, 'symbol': 13};

        for (let m = 0; m < formula.length; m++) {
            d3.select(`#formula${m}`)
                .attr('x', textGap.char*m + textGap.symbol*(m%2))
                .text(formula[m]);
        }
    }

    function updateNumbers() {

        const numberGap = 25;

        let tempX = Math.round(vectorCoords.x/scalingFactor);
        let tempY = Math.round(vectorCoords.y/scalingFactor);
        let tempVel = Math.round(Math.pow(Math.pow(tempX, 2)+Math.pow(tempY, 2), (1/2))*10)/10;

        let chars = d3.range(formula.length).fill(1);
        let charCount = 0;

        chars[0] += tempX.toString().length;
        chars[2] += tempY.toString().length;
        chars[4] += tempVel.toString().length;

        for (let m = 0; m < formula.length; m++) {
            d3.select(`#formula${m}`)
                .attr('x', numberGap*charCount);
            charCount += chars[m];
        }

        d3.select('#formula0').text(`${tempX}²`);
        d3.select('#formula2').text(`${tempY}²`);
        d3.select('#formula4').text(`${tempVel}²`);

    }

</script>

</body>
</html>