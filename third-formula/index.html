<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Third Formula</title>

    <link href="https://fonts.googleapis.com/css?family=Open+Sans" rel="stylesheet">
    <style>

        circle {
            fill: #2c8f9c;
            fill-opacity: 1;
        }

        line {
            stroke: #000;
            stroke-width: 2px;
        }

        text {
            font-family: 'Open Sans', sans-serif;
            font-size: 18px;
            font-weight: bold;
            fill: #000;
        }

        #animation {
            float:left;
        }

        #control {
            float: left;
        }

        .active {
            stroke: #000;
            stroke-width: 2px;
        }

    </style>

</head>
<body>

<div id="animation"></div>
<div id="control"></div>

<script src="https://d3js.org/d3.v4.min.js"></script>
<script>
    'use strict';

    const height = 350;
    const animationWidth = 700;
    const controlWidth = 200;

    const ballRadius = 38;

    const scalingFactor = 29;
    const dotScalingFactor = scalingFactor/150;
    const distScale = 4;

    const formula = ['v²', '=', 'u²', '+', '2', 'x', 'a', 'x', 'x'];
    let eqVars = [{'name': 'dist', 'active': 90, 'eq': 'x = ', 'measure': 'm'},
                  {'name': 'vel', 'active': 90, 'eq': 'u = ', 'measure': 'm/s'},
                  {'name': 'acc', 'active': 90, 'eq': 'a = ', 'measure': 'm/s²'}];
    let lim = {'min': 45, 'max': controlWidth-40,};

    let start = Date.now();
    let animation = false;
    let secondCount = 0;
    let mem = 0;

    initAnimation();
    initControl();

    d3.timer(animate);

    function initAnimation() {

        /* Animation consists of three main elements
         * Ball - moves across screen
         * Formula - displayed top-center
         * Dots - demonstrating start and end position
         */

        let animationSvg = d3.select('div#animation').append('svg')
            .attr('width', animationWidth)
            .attr('height', height);

        initBall();
        initFormula();
        initDots();

        function initBall() {

            const ballOffset = 180 - ballRadius;

            animationSvg.append('g')
                .attr('transform', `translate(${ballRadius},${height - ballOffset})`)
                .attr('id', 'ballContainer');
            d3.select('#ballContainer').append('circle')
                .attr('r', ballRadius)
                .attr('id', 'ball')
                .style('fill-opacity', 0)
                .transition()
                .duration(500)
                .style('fill-opacity', 1);

        }

        function initFormula() {

            const formulaOffset = {'x': 230, 'y': 70};
            const textGap = {'char': 30, 'symbol': 3};
            const fontSize = {'letter': 50, 'symbol': 35};

            animationSvg.append('g')
                .attr('transform', `translate(${formulaOffset.x},${formulaOffset.y})`)
                .attr('id', 'formulaContainer');
            d3.select('#formulaContainer').selectAll('text')
                .data(formula)
                .enter().append('text')
                .attr('x', function(d,i) {return textGap.char*i + textGap.symbol*(i%2) + (i ? 0 : -10) + (i < 3 ? -15 : 0); })
                .attr('y', 0)
                .attr('id', function(d,i) {return `formula${i}`; })
                .text(function(d) {return d; })
                .style('font-size', function(d,i) {return i % 2 ? `${fontSize.symbol}px` : `${fontSize.letter}px`; })
        }

        function initDots() {

            const dots = {'r': 8, 'offset': ballRadius + 20};
            const arrowOffset = 10;
            const numDots = Math.floor(lim.max/scalingFactor) + 1;
            const dotLim = Math.floor(eqVars[1].active/scalingFactor);

            d3.select('#ballContainer').append('g')
                .attr('transform', `translate(0,${-dots.offset})`)
                .attr('id', 'dots');
            d3.select('#dots').selectAll('g')
                .data(d3.range(numDots))
                .enter().append('g')
                .attr('transform', function(d) {return `translate(${distScale*(d <= dotLim ? d : 100)*scalingFactor},0)`; })
                .attr('id', function(d) {return `dots${d}`; });

            for(let j=0; j<numDots; j++) {
                d3.select(`#dots${j}`).append('circle')
                    .attr('r', dots.r)
                    .style('fill', '#000');

                let tempVel = Math.sqrt(Math.pow(convert(eqVars[1].active),2) + 2*convert(eqVars[2].active)*(distScale*j*scalingFactor));
                d3.select(`#dots${j}`).append('line')
                    .attr('x2', tempVel*dotScalingFactor + scalingFactor)
                    .attr('id', `dotLineBody${j}`);
                d3.select(`#dots${j}`).append('g')
                    .attr('transform', `translate(${tempVel*dotScalingFactor + scalingFactor},0)`)
                    .attr('id', `arrowHead${j}`)
                    .selectAll('line')
                    .data(d3.range(2))
                    .enter().append('line')
                    .attr('x2', -arrowOffset)
                    .attr('y2', function(d) {return (d ? -1 : 1) * arrowOffset; });

                let dotText = [{'x': -20, 'y': -20, 'id': `velText${j}`},
                               {'x': -5, 'y': 2*dots.offset, 'id': `distText${j}`}];
                d3.select(`#dots${j}`).selectAll('text')
                    .data(dotText)
                    .enter().append('text')
                    .attr('x', function(d) {return d.x; })
                    .attr('y', function(d) {return d.y; })
                    .attr('id', function(d) {return d.id})
            }

            updateDots();

        }

    }

    function initControl() {
        /* Control consists of three main elements
         * Buttons - Play & pause controls
         * Radio - Toggle between formula and numbers
         * Drag - Draggable controls to modify formula inputs
         */

        let controlSvg = d3.select('div#control').append('svg')
            .attr('height', height)
            .attr('width', controlWidth)
            .style('border', 'solid black 2px');

        initButtons();
        initRadio();
        initDrag();

        function initButtons() {

            const buttonOffset = {'playX': 60, 'pauseX': 110, 'y': 10, 'line': 8};
            const button = {'size': 30, 'rx': 5};

            controlSvg.append('g')
                .attr('transform', `translate(${buttonOffset.playX},${buttonOffset.y})`)
                .attr('id', 'playContainer')
                .on('click', clickPlay);
            d3.select('#playContainer').append('rect')
                .attr('height', button.size)
                .attr('width', button.size)
                .attr('rx', button.rx)
                .attr('fill', '#75b4be')
                .attr('id', 'play')
                .classed('active', animation);
            d3.select('#playContainer').append('path')
                .attr('d', `M${buttonOffset.line} ${buttonOffset.line} L${buttonOffset.line} ${button.size - buttonOffset.line} L${button.size - buttonOffset.line} ${button.size / 2} Z`)
                .style('fill', '#fff');

            controlSvg.append('g')
                .attr('transform', `translate(${buttonOffset.pauseX},${buttonOffset.y})`)
                .attr('id', 'pauseContainer')
                .on('click', clickPause);
            d3.select('#pauseContainer').append('rect')
                .attr('height', button.size)
                .attr('width', button.size)
                .attr('rx', button.rx)
                .attr('fill', '#75b4be')
                .attr('id', 'pause')
                .classed('active', !animation);
            d3.select('#pauseContainer').selectAll('line')
                .data(d3.range(2))
                .enter().append('line')
                .attr('x1', function (d) {
                    return (d + 1) * (button.size / 3);
                })
                .attr('y1', buttonOffset.line)
                .attr('x2', function (d) {
                    return (d + 1) * (button.size / 3);
                })
                .attr('y2', button.size - buttonOffset.line)
                .style('stroke', '#fff')
                .style('stroke-width', `${button.size / 6}px`);

        }

        function initRadio() {

            const radioOffset = {'x': 30, 'y': 60, 'button': 50, 'textX': 20, 'textY': 4};
            const radioRadius = 15;
            const radioText = ['formula', 'numbers'];

            controlSvg.append('g')
                .attr('transform', `translate(${radioOffset.x},${radioOffset.y})`)
                .attr('id', 'radio');
            for (let m = 0; m < radioText.length; m++) {
                d3.select('#radio').append('circle')
                    .attr('cy', radioOffset.button * m)
                    .attr('r', radioRadius)
                    .attr('id', radioText[m] + 'Radio')
                    .style('fill', '#8db6be')
                    .classed('active', !m);
                d3.select('#radio').append('text')
                    .attr('x', radioOffset.textX)
                    .attr('y', radioOffset.button * m + radioOffset.textY)
                    .text(radioText[m]);
            }

            if (d3.select('#formulaRadio').classed('active')) {
                updateFormula();
            } else {
                updateNumbers();
            }

            d3.select('#formulaRadio').on('click', clickFormula);
            d3.select('#numbersRadio').on('click', clickNumbers);
        }

        function initDrag() {

            const fixedBallRadius = 20;
            const dragBallRadius = fixedBallRadius - 5;
            const dragOffset = {'x': fixedBallRadius + 5, 'y': 170, 'gap': 70, 'text': 20, 'dragBall': 5, 'arrow': 10, 'shift': 3};

            for (let n = 0; n < eqVars.length; n++) {
                controlSvg.append('g')
                    .attr('transform', `translate(${dragOffset.x},${height - dragOffset.y + n * dragOffset.gap})`)
                    .attr('id', `${eqVars[n].name}Container`);
                d3.select(`#${eqVars[n].name}Container`).append('text')
                    .attr('x', -fixedBallRadius)
                    .attr('y', (-3 / 2) * dragOffset.text)
                    .attr('id', `${eqVars[n].name}Text`);
                d3.select(`#${eqVars[n].name}Container`).append('line')
                    .attr('id', `${eqVars[n].name}LineBody`);
                d3.select(`#${eqVars[n].name}Container`).append('g')
                    .attr('id', `${eqVars[n].name}DraggableContainer`);
                d3.select(`#${eqVars[n].name}DraggableContainer`).selectAll('line')
                    .data(d3.range(2))
                    .enter().append('line')
                    .attr('x2', -dragOffset.arrow)
                    .attr('y2', function (d) {
                        return (d ? -1 : 1) * dragOffset.arrow
                    });
                d3.select(`#${eqVars[n].name}DraggableContainer`).append('circle')
                    .attr('cx', -dragOffset.arrow + dragOffset.shift)
                    .attr('r', dragBallRadius)
                    .attr('id', `${eqVars[n].name}DragBall`)
                    .style('fill-opacity', 0.2);
                d3.select(`#${eqVars[n].name}Container`).append('circle')
                    .attr('r', fixedBallRadius);

                updateDrag(n);
            }

            d3.select(`#${eqVars[0].name}DragBall`)
                .call(d3.drag()
                    .on('start', dragStart)
                    .on('drag', function () {dragUpdate(0); })
                    .on('end', dragEnd));

            d3.select(`#${eqVars[1].name}DragBall`)
                .call(d3.drag()
                    .on('start', dragStart)
                    .on('drag', function() {dragUpdate(1); })
                    .on('end', dragEnd));

            d3.select(`#${eqVars[2].name}DragBall`)
                .call(d3.drag()
                    .on('start', dragStart)
                    .on('drag', function() {dragUpdate(2); })
                    .on('end', dragEnd));
        }
    }

    function animate() {
        if (animation) {
            secondCount = (Date.now() - start) / 1000;

            // x = u*t + 1/2*a*t^2
            let loc = convert(eqVars[1].active)*secondCount + (1/2)*convert(eqVars[2].active)*Math.pow(secondCount,2);

            d3.select('#ball').attr('cx', loc);

            if (d3.select('#numbersRadio').classed('active')) {
                updateNumbers();
            }

            if (loc > distScale*convert(eqVars[0].active)) {
                clickPause();
                mem = 0;
            }
        }
    }

    function clickPlay() {
        d3.select('#play').classed('active', true);
        d3.select('#pause').classed('active', false);
        start = animation ?  start : (Date.now() - mem);
        animation = true;
    }

    function clickPause() {
        d3.select('#play').classed('active', false);
        d3.select('#pause').classed('active', true);
        mem = Date.now() - start;
        animation = false;
    }

    function clickFormula() {
        d3.select(this).classed('active',true);
        d3.select('#numbersRadio').classed('active', false);

        updateFormula();
    }

    function clickNumbers() {
        d3.select(this).classed('active',true);
        d3.select('#formulaRadio').classed('active', false);

        updateNumbers();
    }

    function dragStart() {
        d3.select(this).classed('active', true);
    }

    function dragUpdate(index) {
        clickPause();
        mem = 0;

        d3.select('#ball')
            .transition()
            .duration(500)
            .attr('cx', 0);

        eqVars[index].active = Math.max(Math.min(d3.event.x+eqVars[index].active, lim.max), lim.min);

        updateDrag(index);
        if (d3.select('#numbersRadio').classed('active')) updateNumbers();
        updateDots();
    }

    function dragEnd() {
        d3.select(this).classed('active', false);
    }

    function updateFormula() {
        for (let m = 0; m < formula.length; m++) {
            d3.select(`#formula${m}`).text(formula[m]);
        }
    }

    function updateNumbers() {
        // x = ut + (1/2)*a*t^2
        let loc = Math.floor(eqVars[1].active/scalingFactor)*secondCount + (1/2)*Math.floor(eqVars[2].active/scalingFactor)*Math.pow(secondCount,2);

        d3.select('#formula2').text(`${Math.floor(eqVars[1].active/scalingFactor)}²`);
        d3.select('#formula6').text(Math.floor(eqVars[2].active/scalingFactor));
        d3.select('#formula8').text(Math.floor(loc/distScale)*distScale);
    }

    function updateDots() {
        const numDots = Math.floor(lim.max/scalingFactor) + 1;

        for(let n=0; n<numDots; n++) {

            let dotLim = Math.floor(eqVars[0].active/scalingFactor);
            // v^2 = u^2 + 2*a*x
            let tempVel = Math.sqrt(Math.pow(convert(eqVars[1].active),2) + 2*convert(eqVars[2].active)*(distScale*n*scalingFactor));

            d3.select(`#dots${n}`)
                .transition()
                .attr('transform', `translate(${distScale * (n <= dotLim ? n : 100) * scalingFactor},0)`);
            d3.select(`#dotLineBody${n}`)
                .transition()
                .attr('x2', tempVel * dotScalingFactor + scalingFactor);
            d3.select(`#arrowHead${n}`)
                .transition()
                .attr('transform', `translate(${tempVel * dotScalingFactor + scalingFactor},0)`);
            d3.select(`#velText${n}`).text(`${Math.round(10 * tempVel / scalingFactor) / 10}m/s`);
            d3.select(`#distText${n}`).text(`${distScale * n}m`);

        }
    }

    function updateDrag(index) {
        d3.select(`#${eqVars[index].name}Text`).text(eqVars[index].eq + (index ? 1 : distScale)*Math.floor(eqVars[index].active/scalingFactor) + eqVars[index].measure);
        d3.select(`#${eqVars[index].name}LineBody`).attr('x2', eqVars[index].active);
        d3.select(`#${eqVars[index].name}DraggableContainer`).attr('transform', `translate(${eqVars[index].active},0)`);
    }

    function convert(input) {
        return Math.floor(input/scalingFactor)*scalingFactor;
    }

</script>

</body>
</html>